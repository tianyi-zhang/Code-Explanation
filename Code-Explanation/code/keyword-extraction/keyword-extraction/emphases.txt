This of course assumes that the public doIt method is only called by a single thread.Like Joda-Time, java.time has a class LocalDate to represent a date-only value without time-of-day and without time zone.the class Separator return the empty String only the first time that it is invoked, then it returns the separator:Then you create a private static final Foo field to hold the only instance, and a public static Foo getInstance() method to return itYes this is our very same hero :) Since the line private static final Foo INSTANCE = new Foo(); is only executed when the class FooLoader is actually used, this takes care of the lazy instantiation,The LocalDate class represents a date-only value without time-of-day and without time zoneThe only problem with this approach is that you need to start JVM with deploy.jar in bootclasspath e.gSay you want to have a function passed in with a String param that returns an int. First you have to define an interface with the function as its only member, if you can't reuse an existing one.The only way to really find out is by reading (you'll get -1 as return value) or writing (an IOException (broken pipe) will be thrown) on the associated Input/OutputStreams.Element is an implementation of Node, but certainly not the only oneThere is no WeakHashSet implementation in the standard Java library only a WeakHashMap but we can easily use the latter one to "implement" the functionality of the first one:(The with reference only access is very useful.) If you use protected instead of private for the accessors/references, sub-classes of Foo can even return extended references from getReference[EDIT: as commented below I no longer remember my reasoning for this sentence and it is likely wrong: "Note that this will only work in abstract classes, first of all."] The next difficulty is that g() only works from DIRECT subclasses of AWith multiple bounds, only the left-most bound is considered for the erasure, so if max is given the following signature:Arrays.sort only accepts a Comparator when being passed an Object[]The method toString accept only a String as codepage parameter (stand Java 8).Or you can design the class so that name always has a non-null value:In fact there is only one way: it can only happen if foo has the value nullwhere the find method is statically imported from a PersistenceFacade class which defines only static methods, and encapsulates how to obtain the proper Session/EntityManager instanceNote that Iterator.remove is the only safe way to modify a collection during iteration; the behavior is unspecified if the underlying collection is modified in any other way while the iteration is in progress.You might want to look into either creating a class that implements the HttpSession interface yourself for the purposes of unit testing only (a stub), and running your tests off of that, or you should take a look at dwnLoadCel and determine if it really needs to have a reference to the HttpSession, or if it just needs some properties within the HttpSessionSince the method you're testing (dwnLoadCel.doAuthorization()) only depends on an HttpSession object, that is what you should mockSimilarly, you can validate if a String is a float or a double but in those cases you have to encounter only one . (dot) in the String and of course check if digits == (aString.length()-1)I believe there's zero risk running into an exception, because as you can see below you always safely parse int to String and not the other way around.You only have to grab it as Document, not as a String.If I understood your problem correctly, MyMDB listens to a topic on WebLogic, and you want to use an additional JMS destination provided by JBoss, defined in a deployed configuration file and identified by its JNDI name (by default, deploy/jms/jms-ds.xml only contains the configuration for the JMS provider and connection factories -- no data sources).The only issue I had is about unwanted scrollbars from the wrapping JScrollPaneIf you only need this for writing an InputStream to a File then you can use this simple function:As you can see, the only difference is all the redundant casts to Object.