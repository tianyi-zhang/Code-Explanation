I was all in favour of throwing IllegalArgumentException for null parameters, until today, when I noticed the java.util.Objects.requireNonNull method in Java 7BTW getClass().getClassLoader().getResourceAsStream("/img/bg.png") - which I tried first - returned me a null InputStream.This assumes that you can do the error handling in the public doIt method, since the count variable isn't actually passed back to the callerNote that this is bad coding style, although the compiler will almost certainly catch your error the moment you try to use d.And as @Recurse noted (but apparently -1 me) you can do the preceding with out making String name final to get the compiler error (which I never said you couldn't) but you could easily make the compiler error go away setting name after the switch statement which throws away the expression semantics or worse forgetting to break which you cannot cause an error (despite what @Recurse says) without using final:with a manager.removeListener(myListenerImpl) because it will be automatically removed once your listener or your component holding the listener becomes unavailable.Use the ImmutableList class and its of() and copyOf() factory methods (elements can't be null):However, it cannot set the list (except setting it to null), because it does not know exactly what kind of list is represented by the ?.On the first line inside main I'm explicitly setting the Object reference obj to nullIf you attempt to dereference num BEFORE creating the object you get a NullPointerExceptionThis particular NPE can be avoided if the comparison order is reversed; namely, use .equals on a guaranteed non-null object.The variable can have a default value (and setName can prevent it being set to null):We find out that s is null, and calling the length method on it throws the exceptionEither the print or printString method can check for null, for example:By following the callers of the method, we see that s is passed in with printString(name) in the print() method, and this.name is null.Or you can design the class so that name always has a non-null value:So what about our 2nd scenario? Well we can see that pos is 1, so that means that foo[1] must be nullIn fact there is only one way: it can only happen if foo has the value nullAnd we can see clearly that we initialized foo to a non-null value(In theory, something else could change foo to null ..the best way is to use the remove method of the iterator object, I would go into the specifics of the place where the error "java.util.ConcurrentModificationException" is thrown.It's actually rare for me to use the idiom "if (object != null && ...".Then, in the rest of that method, you'll know that object is not null.Method validate() will throw checked ValidationException if any of the parameters is null (checked or unchecked is more a design/taste issue, but my ValidationException is checked).This is rather theoretical case and in most cases you should prefer java null safe API, but NullPointerException is subclass of an Exception. Thus it is a form of Throwable that indicates conditions that a reasonable application might want to catch (javadoc)! To use the first most advantage of exceptions and separate error-handling code from 'regular' code (according to creators of Java) it is appropriate, as for me, to catch NullPointerException....with two lists of arguments: "", null and null, ImmutableList.of()